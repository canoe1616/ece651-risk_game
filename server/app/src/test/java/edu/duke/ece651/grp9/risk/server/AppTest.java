/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package edu.duke.ece651.grp9.risk.server;

import edu.duke.ece651.grp9.risk.shared.Action;
import edu.duke.ece651.grp9.risk.shared.AttackAction;
import edu.duke.ece651.grp9.risk.shared.MapFactory;
import edu.duke.ece651.grp9.risk.shared.Map;
import edu.duke.ece651.grp9.risk.shared.MoveAction;
import edu.duke.ece651.grp9.risk.shared.Player;
import edu.duke.ece651.grp9.risk.shared.Territory;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.net.Socket;
import java.util.HashSet;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;

import static org.junit.jupiter.api.Assertions.*;

class AppTest {

  @Test
  public void test_constructor() {
    MapFactory factory = new MapFactory();
    Map map = factory.makeMapForTwo();
    App app1 = new App(map);
  }

  /*@Test
  @Timeout(5)
  public void test_selectColor() throws IOException, InterruptedException, ClassNotFoundException {
    MapFactory factory = new MapFactory();
    Map map = factory.makeMapForTwo();
    App app = new App(map);
    Thread th = new Thread() {
      @Override()
      public void run() {
        try {
          App.main(new String[0]);
        } catch (Exception e) {
          System.out.println("Connection error.");
        }
      }
    };
    th.start();
    Thread.sleep(100);

    Socket socket = new Socket("localhost", 6666);

    InputStream inputStream = socket.getInputStream();
    ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);
    Map map1 = (Map) objectInputStream.readObject();

    String networkMessage = (String) objectInputStream.readObject();
    String message = "Please select what color you would like to play as: red blue";
    assertEquals(networkMessage, message);

    th.interrupt();
    th.join();
  }*/

  @Test
  public void test_findPlayer() {
    MapFactory factory = new MapFactory();
    Map map = factory.makeMapForTwo();
    App app = new App(map);

    assertEquals(app.findPlayer("red", map), new Player("red"));
    assertEquals(app.findPlayer("blue", map), new Player("blue"));
    assertEquals(app.findPlayer("yellow", map), null);
  }

  @Test
  public void test_deleteColor() {
    MapFactory factory = new MapFactory();
    Map map = factory.makeMapForTwo();
    App app = new App(map);

    assertTrue(app.deleteColor("red"));
    assertFalse(app.deleteColor("yellow"));
    assertTrue(app.deleteColor("blue"));
  }

  @Test
  public void test_playerUnitSetting() {
    MapFactory factory = new MapFactory();
    Map map = factory.makeMapForTwo();

    Player p1 = map.findPlayer("red");
    App app1 = new App(map);

    for (Territory t : p1.getTerritoryList()) {
      assertEquals(t.getUnit(), 0);
    }

    app1.playerUnitSetting("10 10", p1);
    for (Territory t : p1.getTerritoryList()) {
      assertEquals(t.getUnit(), 10);
    }
  }

  @Test
  public void test_createAction() {
    MapFactory factory = new MapFactory();
    Map map = factory.makeMapForTwo();
    Player p1 = map.findPlayer("red");
    App app1 = new App(map);

    MoveAction move1 = (MoveAction) app1.createAction(map, "red", "A B 5", true);

    assertEquals(move1.getPlayer(), p1);
    assertNotEquals(move1, null);

    MoveAction move2 = (MoveAction) app1.createAction(map, "red", "A F 5", true);
    assertEquals(move2, null);

    MoveAction move3 = (MoveAction) app1.createAction(map, "red", "A F a", true);
    assertEquals(move3, null);
  }

  @Test
  public void test_validActionSet() {
    MapFactory factory = new MapFactory();
    Map map = factory.makeMapForTwo();
    App app1 = new App(map);
    Player p1 = app1.findPlayer("red", map);

    HashSet<MoveAction> moves = new HashSet<>();
    HashSet<AttackAction> attacks = new HashSet<>();
    moves.add((MoveAction) app1.createAction(map, "red", "A B 5", true));
    String error1 = "These actions are invalid: A territory ends with negative units";
    assertEquals(app1.validActionSet(p1, moves, attacks), error1);
    moves.clear();

    moves.add((MoveAction) app1.createAction(map, "red", "A F 5", true));
    String error2 = "This action is invalid: Territory does not exist";
    assertEquals(app1.validActionSet(p1, moves, attacks), error2);
    moves.clear();

    attacks.add((AttackAction) app1.createAction(map, "red", "A F 5", false));
    assertEquals(app1.validActionSet(p1, moves, attacks), error2);
    attacks.clear();

    moves.add((MoveAction) app1.createAction(map, "red", "A C 3", true));
    String error3 = "This action is invalid: A is not connected to C.";
    assertEquals(app1.validActionSet(p1, moves, attacks), error3);
    moves.clear();

    attacks.add((AttackAction) app1.createAction(map, "red", "A B 5", false));
    String error4 = "This action is invalid: you cannot attack your own Territory.";
    assertEquals(app1.validActionSet(p1, moves, attacks), error4);
    moves.clear();
    attacks.clear();

    for (Territory t : p1.getTerritoryList()) {
      t.syncUnits();
    }
    moves.add((MoveAction) app1.createAction(map, "red", "A B 0", true));
    attacks.add((AttackAction) app1.createAction(map, "red", "A C 0", false));
    assertEquals(app1.validActionSet(p1, moves, attacks), null);
  }

  @Test
  public void test_playAttacks() {

  }
}
