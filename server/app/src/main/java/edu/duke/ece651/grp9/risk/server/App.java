/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package edu.duke.ece651.grp9.risk.server;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.concurrent.TimeUnit;

//import edu.duke.ece651.grp9.risk.shared.MapPackage;
//import edu.duke.ece651.grp9.risk.shared.Message;
import edu.duke.ece651.grp9.risk.shared.*;
import org.checkerframework.checker.units.qual.A;


public class App {
  private static HashSet<String> remainingColors;
  public App() {
    remainingColors = new HashSet<>();
  }

  public App(Map m){
    remainingColors = new HashSet<>();
    Iterator<Player> it = m.getPlayer().iterator();
    while(it.hasNext()){
      remainingColors.add(it.next().getName());
    }
  }
  

  public void selectColor(ObjectOutputStream stream) {
    StringBuilder sb = new StringBuilder();
    sb.append("Please select what color you would like to play as: ");
    for (String color : remainingColors) {
      sb.append(color + " ");
    }
    try {
      stream.writeObject(sb.toString());
    } catch(Exception e) {
      System.out.println(e);
    }
  }
  
  public boolean deleteColor(String color){
    for (String c : remainingColors) {
      if(c.equals(color)){
        remainingColors.remove(color);
        return true;
      }
    }
    return false;
  }


  public void unitSetting(ObjectOutputStream stream, Player player){

    StringBuilder sb = new StringBuilder();
    sb.append("You have " + player.getTerritoryNumber()+ " territories: ");
    for(Territory ter : player.getTerritoryList()){
      sb.append(ter.getName()+ " ");
    }
    sb.append("\n");
    sb.append("You have 30 total units, how do you want to place the units?");
    try {
      stream.writeObject(sb.toString());
    } catch(Exception e) {
      System.out.println(e);
    }
  }

  public Player findPlayer(String color, Map m){
    HashSet<Player> list = m.getPlayer();
    Iterator<Player> it = list.iterator();
    while(it.hasNext()){
      Player pyr = it.next();
      if(pyr.getName().equals(color)){
        return pyr;
      }
     }
    return null;
  }


  public void playerUnitSetting(String unitString, Player player){

    ArrayList<Integer> unitList = new ArrayList<>();
    char[] tmp = unitString.toCharArray();

    //unitString -> array
    int k = 0;
    int digit = 0;
    while(k < tmp.length){

      if(Character.isDigit(tmp[k])){
        digit =0 ;
        while(k < tmp.length && Character.isDigit(tmp[k])){
          digit = digit*10 + Character. getNumericValue(tmp[k]);
          k++;
        }
      }
      unitList.add(digit);
      k++;
    }
    int i = 0;
    for(Territory ter: player.getTerritoryList()){
      ter.setUnit(unitList.get(i));
      i++;
    }
  }
  /**
   * Creates an Action given String input from client
   *
   * @param map Map we are checking to see if Territory and Player exists
   * @param action String input from client to be converted to Action
   * @param isMove boolean to indicate if creating MoveAction or AttackAction
   * @return Action as indicated by client
   */
  public Action createAction(Map map, String action, boolean isMove) {
    int numUnits = -1;

    String[] words = action.split(" ");
    Player player = map.findPlayer(words[0]);
    Territory source = map.findTerritory(words[1]);
    Territory destination = map.findTerritory(words[2]);
    try {
      numUnits = Integer.parseInt(words[3]);
    } catch (NumberFormatException e) {
    }

    if (source == null || destination == null) {
      return null;
    }

    if (isMove) {
      return new MoveAction(player, source, destination, numUnits);
    } else {
      return new AttackAction(player, source, destination, numUnits);
    }
  }
  public String getPlayer(String action) {
    String[] words = action.split(" ");
    return words[0];
  }

  public String validActionSet(HashSet<MoveAction> moves, HashSet<AttackAction> attacks) {
    Player player = null;
    for (MoveAction move : moves) {
      if (move == null) {
        return "This action is invalid: Territory does not exist";
      }
      String error = move.canPerformAction();
      if (error != null) {
        return error;
      }
      player = move.getPlayer();
    }

    for (AttackAction attack : attacks) {
      if (attack == null) {
        return "This action is invalid: Territory does not exist";
      }
      String error = attack.canPerformAction();
      if (error != null) {
        return error;
      }
      player = attack.getAttacker();
    }

    if (player == null) {
      return null;
    }

    for (Territory territory : player.getTerritoryList()) {
      if (!territory.mockIsValid()) {
        return "These actions are invalid: " + territory.getName()
            + " territory ends with negative units";
      }
    }

    return null;
  }


  /**
   * play all received attacks
   * @param attacks received attacks
   */
  private void playAttacks(HashSet<AttackAction> attacks) {
    Battle battle = new Battle();
    for (AttackAction att: attacks) {
      battle.addAttackAction(att);
    }
    battle.playBattlePhase();
  }

  //boolean
  public static <objectInputStream> void main(String[] args) {
    
    MapFactory f = new MapFactory();
    Map m = f.makeMapForThree();
    int player_num = 3;
    App app = new App(m);
    ArrayList<Socket> socketList = new ArrayList<Socket>();
    Socket socket = null;

    //debug
    ArrayList<ObjectInputStream> InputList = new ArrayList<ObjectInputStream>();
    ArrayList<ObjectOutputStream> OutputList = new ArrayList<ObjectOutputStream>();



    try(ServerSocket ss = new ServerSocket(6666)){
      for(int i = 0; i<player_num; i++){
        Socket s = ss.accept();
        socketList.add(s);
      }

      for(int i=0; i<socketList.size(); i++){
      //add the checker
      ActionRuleChecker tmp = new ActionRuleChecker();

      socket = socketList.get(i);
      
      //send map object
      OutputStream outputStream = socket.getOutputStream();
      ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);
      objectOutputStream.writeObject(m);
      OutputList.add(objectOutputStream);

      InputStream inputStream = socket.getInputStream();
      ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);
      InputList.add(objectInputStream);


      app.selectColor(objectOutputStream);
      //check if the color selection is valid
      String color = "";
      while(true){

        //boolean for color checking

      String color_correct = "true";
      //InputStream inputStream = socket.getInputStream();
      //ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);
      color = (String)objectInputStream.readObject();

      // add the checker
        //if everything is good, we will send "true" to the client

      //System.out.println(color);
      while(tmp.checkColor(color, remainingColors) != null){

        //System.out.println(tmp.checkColor(color, remainingColors));
        color_correct = "false";
        
        objectOutputStream.writeObject("false");

        //read the new color from the client
        color = (String)objectInputStream.readObject();
        }

      if(tmp.checkColor(color, remainingColors) == null) {
        color_correct = "true";
          objectOutputStream.writeObject(color_correct);
           app.deleteColor(color);
           break;
      }
      }
      //read unit assignment
      app.unitSetting(objectOutputStream, app.findPlayer(color, m));
      String unitString = "";
      while(true){
        String unit_correct = "true";
        //InputStream inputStream = socket.getInputStream();
        //ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);

        unitString = (String)objectInputStream.readObject();

        // add the checker

        while(tmp.checkUnit(unitString, app.findPlayer(color, m)) != null){
          //System.out.println(unitString);
          unit_correct = "false";
          objectOutputStream.writeObject("false");
          unitString = (String)objectInputStream.readObject();
          //objectOutputStream.reset();

        }
        
        if(tmp.checkUnit(unitString, app.findPlayer(color, m)) == null) {
           unit_correct = "true";
           objectOutputStream.writeObject(unit_correct);
           //objectOutputStream.reset();
            System.out.println(unitString);
            app.playerUnitSetting(unitString, app.findPlayer(color, m));
           break;
        }

      }
      }

//-------------------end of initial placement----------------//

      // initial sets for player actions
      //ActionSet actionSet = new ActionSet();
      HashSet<MoveAction> allMoves = new HashSet<>();
      HashSet<AttackAction> allAttack = new HashSet<>();

      // if we find the winner, notify the winner he wins the game;
      // notify the other players game over
      if (m.getGameWinner() != null) {
        int i = 0;
        for (Player player: m.getPlayer()) {
          OutputList.get(i).reset();
          OutputList.get(i).writeObject(m);
          if (player.equals(m.getGameWinner())) {
            OutputList.get(i).reset();
            OutputList.get(i).writeObject("win");
          } else {
            OutputList.get(i).reset();
            OutputList.get(i).writeObject("game over");
          }
          i++;
        }
        // game over, Socket disconnection
        ss.close();

      } else { // no winner detected, game continuing
        int i = 0;
        for (Player player : m.getPlayer()) {
          
          // notify player game not over yet
          OutputList.get(i).writeObject("game continuing");
          if (player.isLose()) {
            if (player.getLoseStatus() == "quit" && m.getPlayer().contains(player)) {
              //remove it from player list
              //auto set empty actionSet
              m.removePlayer(player);
            }
            if (player.getLoseStatus() == "continue") {
              //send map to it for each round
              //auto set empty actionSet
              OutputList.get(i).writeObject(m);
            }
          } else { // if the player still alive
            ActionSet actionSet = (ActionSet) InputList.get(i).readObject();
            HashSet<MoveAction> moveActions = new HashSet<>();
            HashSet<AttackAction> attackActions = new HashSet<>();

            OutputList.get(i).reset();
            OutputList.get(i).writeObject(m);
            actionSet = (ActionSet) InputList.get(i).readObject();
            System.out.println("Get action...");
            HashSet<String> actionListMove = actionSet.getMoveList();
            
            for (String move : actionListMove) {
              moveActions.add((MoveAction) app.createAction(m, move, true));
            }

            HashSet<String> actionListAttack = actionSet.getAttackList();
            for (String attack : actionListAttack) {
              attackActions.add((AttackAction) app.createAction(m, attack, false));
            }

            String actionProblem = app.validActionSet(moveActions, attackActions);
            OutputList.get(i).writeObject(actionProblem);
        if (actionProblem == null) {
          allMoves.addAll(moveActions);
          allAttack.addAll(attackActions);
        } else {
          //System.out.println(actionProblem);
          i--;
        }

        System.out.println("Get actions...");
      }

      // real execute for thr move action
      for(MoveAction act: allMoves){
        act.performAction();
      }

      //real execute for te attack action
      for(AttackAction att: allAttack){
        att.performAction();
      }
          i++;
        }
        TimeUnit.SECONDS.sleep(1000);
      }

//      for(int i=0; i<socketList.size(); i++){
//        //add the rule checker
//        //socket = socketList.get(i);
//        //send the map again
//
//        OutputList.get(i).reset();
//        OutputList.get(i).writeObject(m);
//        //To show the map in the server side- 【debug】
//        MapTextView mtv = new MapTextView(m);
//        String gameStateInitial = mtv.displayGameState(app.findPlayer("red", m));
//        System.out.println(gameStateInitial);
//
//        System.out.println("Sent map");
//      }

//      for(int i =0; i<socketList.size(); i++){
//        //get the action sets from client
//        actionSet = (ActionSet)InputList.get(i).readObject();
//        System.out.println("Get action...");
//      }
//
//      TimeUnit.SECONDS.sleep(1000);
//    ss.close();
  }
    catch(Exception e){
      System.out.println(e);
    }
  }
}
;
